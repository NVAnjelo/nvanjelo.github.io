---

title: "/home/anarendran/Documents/temp/rivet/analyses/pluginLHCb/LHCB_2015_I1333223.cc"

---

# /home/anarendran/Documents/temp/rivet/analyses/pluginLHCb/LHCB_2015_I1333223.cc



## Namespaces

| Name           |
| -------------- |
| **[Rivet](http://example.org/namespaces/namespacerivet/)** <br>-*- C++ -*-  |

## Classes

|                | Name           |
| -------------- | -------------- |
| class | **[Rivet::LHCB_2015_I1333223](http://example.org/classes/classrivet_1_1lhcb__2015__i1333223/)**  |




## Source code

```cpp
// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/Tools/Logging.hh"
#include "Rivet/Projections/ChargedFinalState.hh"
#include "Rivet/Math/Units.hh"
#include <vector>

using namespace std;

namespace Rivet {


  class  LHCB_2015_I1333223 : public Analysis {
  public:



     LHCB_2015_I1333223()
      : Analysis("LHCB_2015_I1333223")
    {    }



  public:



    void init() {
      // Charged particles
      declare(ChargedFinalState(Cuts::eta> 2.0 && Cuts::eta <4.5 && Cuts::pT >0.2*GeV), "CFS");
      // Reproducing only measurement for prompt charged particles
      book(_hInelasticXs ,1, 1, 1);
    }


    void analyze(const Event& event) {
      const ChargedFinalState   &cfs    = apply<ChargedFinalState> (event, "CFS");

      // eliminate non-inelastic events and empty events in LHCb
      if (cfs.particles().size() == 0) vetoEvent;

      // See if this event has at least one prompt particle
      for (const Particle &myp : cfs.particles()){
          double dPV = getPVDCA(myp);
          // if IP > 200 microns the particle is not considered prompt
          if ((dPV < 0.) || (dPV > 0.2 * millimeter)) {
            MSG_DEBUG(" Vetoing " << myp.pid() << " at " << dPV);
            continue;
          }
          // histo gets filled only for inelastic events (at least one prompt charged particle)
          _hInelasticXs->fill(sqrtS());
          break;
      } //end loop on particles

    }


    void finalize() {
      scale(_hInelasticXs, crossSection()/sumOfWeights()/millibarn);
    }



  private:

    double getPVDCA(const Particle& p) {
      ConstGenVertexPtr vtx = p.genParticle()->production_vertex();
      if ( 0 == vtx ) return -1.;

      // Unit vector of particle's MOMENTUM three vector
      const Vector3 u = p.momentum().p3().unit();

      // The interaction point is always at (0, 0,0,0) hence the
      // vector pointing from the PV to the particle production vertex is:
      Vector3 d(vtx->position().x(), vtx->position().y(), vtx->position().z());

      // Subtract projection of d onto u from d
      double proj = d.dot(u);
      d -= (u * proj);

      // d should be orthogonal to u and it's length give the distance of
      // closest approach
      return d.mod();
    }



    Histo1DPtr _hInelasticXs;
    //
  };



  // The hook for the plugin system
  RIVET_DECLARE_PLUGIN(LHCB_2015_I1333223);

}
```


-------------------------------

Updated on 2022-07-27 at 19:10:15 +0100
