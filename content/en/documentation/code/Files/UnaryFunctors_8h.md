---

title: "/home/anarendran/Documents/temp/rivet/include/Rivet/Math/eigen3/src/Core/functors/UnaryFunctors.h"

---

# /home/anarendran/Documents/temp/rivet/include/Rivet/Math/eigen3/src/Core/functors/UnaryFunctors.h



## Namespaces

| Name           |
| -------------- |
| **[Eigen](http://example.org/namespaces/namespaceeigen/)**  |
| **[Eigen::internal](http://example.org/namespaces/namespaceeigen_1_1internal/)**  |

## Classes

|                | Name           |
| -------------- | -------------- |
| struct | **[Eigen::internal::scalar_opposite_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__opposite__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_opposite_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__opposite__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_abs_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__abs__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_abs_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__abs__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_score_coeff_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__score__coeff__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_score_coeff_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__score__coeff__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::abs_knowing_score](http://example.org/classes/structeigen_1_1internal_1_1abs__knowing__score/)**  |
| struct | **[Eigen::internal::abs_knowing_score< Scalar, typename scalar_score_coeff_op< Scalar >::Score_is_abs >](http://example.org/classes/structeigen_1_1internal_1_1abs__knowing__score_3_01scalar_00_01typename_01scalar__score__coeff__89f9c229e512182c485dc9a5234e50a4/)**  |
| struct | **[Eigen::internal::scalar_abs2_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__abs2__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_abs2_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__abs2__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_conjugate_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__conjugate__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_conjugate_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__conjugate__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_arg_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__arg__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_arg_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__arg__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_cast_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__cast__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_cast_op< Scalar, NewType > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__cast__op_3_01scalar_00_01newtype_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_real_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__real__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_real_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__real__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_imag_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__imag__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_imag_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__imag__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_real_ref_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__real__ref__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_real_ref_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__real__ref__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_imag_ref_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__imag__ref__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_imag_ref_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__imag__ref__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_exp_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__exp__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_exp_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__exp__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_log_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__log__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_log_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__log__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_log1p_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__log1p__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_log1p_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__log1p__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_log10_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__log10__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_log10_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__log10__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_sqrt_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__sqrt__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_sqrt_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__sqrt__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_rsqrt_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__rsqrt__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_rsqrt_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__rsqrt__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_cos_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__cos__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_cos_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__cos__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_sin_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__sin__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_sin_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__sin__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_tan_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__tan__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_tan_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__tan__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_acos_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__acos__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_acos_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__acos__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_asin_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__asin__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_asin_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__asin__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_atan_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__atan__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_atan_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__atan__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_tanh_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__tanh__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_tanh_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__tanh__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_sinh_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__sinh__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_sinh_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__sinh__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_cosh_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__cosh__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_cosh_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__cosh__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_inverse_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__inverse__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_inverse_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__inverse__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_square_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__square__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_square_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__square__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_cube_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__cube__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_cube_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__cube__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_round_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__round__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_round_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__round__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_floor_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__floor__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_floor_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__floor__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_ceil_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__ceil__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_ceil_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__ceil__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_isnan_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__isnan__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_isnan_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__isnan__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_isinf_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__isinf__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_isinf_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__isinf__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_isfinite_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__isfinite__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_isfinite_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__isfinite__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_boolean_not_op](http://example.org/classes/structeigen_1_1internal_1_1scalar__boolean__not__op/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_boolean_not_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__boolean__not__op_3_01scalar_01_4_01_4/)**  |
| struct | **[Eigen::internal::scalar_sign_op< Scalar, false >](http://example.org/classes/structeigen_1_1internal_1_1scalar__sign__op_3_01scalar_00_01false_01_4/)**  |
| struct | **[Eigen::internal::scalar_sign_op< Scalar, true >](http://example.org/classes/structeigen_1_1internal_1_1scalar__sign__op_3_01scalar_00_01true_01_4/)**  |
| struct | **[Eigen::internal::functor_traits< scalar_sign_op< Scalar > >](http://example.org/classes/structeigen_1_1internal_1_1functor__traits_3_01scalar__sign__op_3_01scalar_01_4_01_4/)**  |




## Source code

```cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2008-2016 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef EIGEN_UNARY_FUNCTORS_H
#define EIGEN_UNARY_FUNCTORS_H

namespace Eigen {

namespace internal {

template<typename Scalar> struct scalar_opposite_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_opposite_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }
  template<typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
  { return internal::pnegate(a); }
};
template<typename Scalar>
struct functor_traits<scalar_opposite_op<Scalar> >
{ enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasNegate };
};

template<typename Scalar> struct scalar_abs_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_abs_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs(a); }
  template<typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
  { return internal::pabs(a); }
};
template<typename Scalar>
struct functor_traits<scalar_abs_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasAbs
  };
};

template<typename Scalar> struct scalar_score_coeff_op : scalar_abs_op<Scalar>
{
  typedef void Score_is_abs;
};
template<typename Scalar>
struct functor_traits<scalar_score_coeff_op<Scalar> > : functor_traits<scalar_abs_op<Scalar> > {};

/* Avoid recomputing abs when we know the score and they are the same. Not a true Eigen functor.  */
template<typename Scalar, typename=void> struct abs_knowing_score
{
  EIGEN_EMPTY_STRUCT_CTOR(abs_knowing_score)
  typedef typename NumTraits<Scalar>::Real result_type;
  template<typename Score>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a, const Score&) const { return numext::abs(a); }
};
template<typename Scalar> struct abs_knowing_score<Scalar, typename scalar_score_coeff_op<Scalar>::Score_is_abs>
{
  EIGEN_EMPTY_STRUCT_CTOR(abs_knowing_score)
  typedef typename NumTraits<Scalar>::Real result_type;
  template<typename Scal>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scal&, const result_type& a) const { return a; }
};

template<typename Scalar> struct scalar_abs2_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_abs2_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }
  template<typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,a); }
};
template<typename Scalar>
struct functor_traits<scalar_abs2_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };

template<typename Scalar> struct scalar_conjugate_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_conjugate_op)
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }
  template<typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }
};
template<typename Scalar>
struct functor_traits<scalar_conjugate_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,
    PacketAccess = packet_traits<Scalar>::HasConj
  };
};

template<typename Scalar> struct scalar_arg_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_arg_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using numext::arg; return arg(a); }
  template<typename Packet>
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
  { return internal::parg(a); }
};
template<typename Scalar>
struct functor_traits<scalar_arg_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::IsComplex ? 5 * NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasArg
  };
};
template<typename Scalar, typename NewType>
struct scalar_cast_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_cast_op)
  typedef NewType result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }
};
template<typename Scalar, typename NewType>
struct functor_traits<scalar_cast_op<Scalar,NewType> >
{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };

template<typename Scalar>
struct scalar_real_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_real_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }
};
template<typename Scalar>
struct functor_traits<scalar_real_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };

template<typename Scalar>
struct scalar_imag_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }
};
template<typename Scalar>
struct functor_traits<scalar_imag_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };

template<typename Scalar>
struct scalar_real_ref_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_real_ref_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }
};
template<typename Scalar>
struct functor_traits<scalar_real_ref_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };

template<typename Scalar>
struct scalar_imag_ref_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_ref_op)
  typedef typename NumTraits<Scalar>::Real result_type;
  EIGEN_DEVICE_FUNC
  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }
};
template<typename Scalar>
struct functor_traits<scalar_imag_ref_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };

template<typename Scalar> struct scalar_exp_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_exp_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::exp(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }
};
template <typename Scalar>
struct functor_traits<scalar_exp_op<Scalar> > {
  enum {
    PacketAccess = packet_traits<Scalar>::HasExp,
    // The following numbers are based on the AVX implementation.
#ifdef EIGEN_VECTORIZE_FMA
    // Haswell can issue 2 add/mul/madd per cycle.
    Cost =
    (sizeof(Scalar) == 4
     // float: 8 pmadd, 4 pmul, 2 padd/psub, 6 other
     ? (8 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost)
     // double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other
     : (14 * NumTraits<Scalar>::AddCost +
        6 * NumTraits<Scalar>::MulCost +
        scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))
#else
    Cost =
    (sizeof(Scalar) == 4
     // float: 7 pmadd, 6 pmul, 4 padd/psub, 10 other
     ? (21 * NumTraits<Scalar>::AddCost + 13 * NumTraits<Scalar>::MulCost)
     // double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other
     : (23 * NumTraits<Scalar>::AddCost +
        12 * NumTraits<Scalar>::MulCost +
        scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))
#endif
  };
};

template<typename Scalar> struct scalar_log_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_log_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog(a); }
};
template <typename Scalar>
struct functor_traits<scalar_log_op<Scalar> > {
  enum {
    PacketAccess = packet_traits<Scalar>::HasLog,
    Cost =
    (PacketAccess
     // The following numbers are based on the AVX implementation.
#ifdef EIGEN_VECTORIZE_FMA
     // 8 pmadd, 6 pmul, 8 padd/psub, 16 other, can issue 2 add/mul/madd per cycle.
     ? (20 * NumTraits<Scalar>::AddCost + 7 * NumTraits<Scalar>::MulCost)
#else
     // 8 pmadd, 6 pmul, 8 padd/psub, 20 other
     ? (36 * NumTraits<Scalar>::AddCost + 14 * NumTraits<Scalar>::MulCost)
#endif
     // Measured cost of std::log.
     : sizeof(Scalar)==4 ? 40 : 85)
  };
};

template<typename Scalar> struct scalar_log1p_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_log1p_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log1p(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog1p(a); }
};
template <typename Scalar>
struct functor_traits<scalar_log1p_op<Scalar> > {
  enum {
    PacketAccess = packet_traits<Scalar>::HasLog1p,
    Cost = functor_traits<scalar_log_op<Scalar> >::Cost // TODO measure cost of log1p
  };
};

template<typename Scalar> struct scalar_log10_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_log10_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD_MATH(log10) return log10(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog10(a); }
};
template<typename Scalar>
struct functor_traits<scalar_log10_op<Scalar> >
{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };

template<typename Scalar> struct scalar_sqrt_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sqrt(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }
};
template <typename Scalar>
struct functor_traits<scalar_sqrt_op<Scalar> > {
  enum {
#if EIGEN_FAST_MATH
    // The following numbers are based on the AVX implementation.
    Cost = (sizeof(Scalar) == 8 ? 28
                                // 4 pmul, 1 pmadd, 3 other
                                : (3 * NumTraits<Scalar>::AddCost +
                                   5 * NumTraits<Scalar>::MulCost)),
#else
    // The following numbers are based on min VSQRT throughput on Haswell.
    Cost = (sizeof(Scalar) == 8 ? 28 : 14),
#endif
    PacketAccess = packet_traits<Scalar>::HasSqrt
  };
};

template<typename Scalar> struct scalar_rsqrt_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_rsqrt_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(1)/numext::sqrt(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::prsqrt(a); }
};

template<typename Scalar>
struct functor_traits<scalar_rsqrt_op<Scalar> >
{ enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasRsqrt
  };
};

template<typename Scalar> struct scalar_cos_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_cos_op)
  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return numext::cos(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }
};
template<typename Scalar>
struct functor_traits<scalar_cos_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasCos
  };
};

template<typename Scalar> struct scalar_sin_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_sin_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sin(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psin(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sin_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasSin
  };
};


template<typename Scalar> struct scalar_tan_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_tan_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::tan(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }
};
template<typename Scalar>
struct functor_traits<scalar_tan_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasTan
  };
};

template<typename Scalar> struct scalar_acos_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_acos_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::acos(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }
};
template<typename Scalar>
struct functor_traits<scalar_acos_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasACos
  };
};

template<typename Scalar> struct scalar_asin_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_asin_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::asin(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }
};
template<typename Scalar>
struct functor_traits<scalar_asin_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasASin
  };
};


template<typename Scalar> struct scalar_atan_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_atan_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::atan(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::patan(a); }
};
template<typename Scalar>
struct functor_traits<scalar_atan_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasATan
  };
};

template <typename Scalar>
struct scalar_tanh_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_tanh_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::tanh(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& x) const { return ptanh(x); }
};

template <typename Scalar>
struct functor_traits<scalar_tanh_op<Scalar> > {
  enum {
    PacketAccess = packet_traits<Scalar>::HasTanh,
    Cost = ( (EIGEN_FAST_MATH && is_same<Scalar,float>::value)
// The following numbers are based on the AVX implementation,
#ifdef EIGEN_VECTORIZE_FMA
                // Haswell can issue 2 add/mul/madd per cycle.
                // 9 pmadd, 2 pmul, 1 div, 2 other
                ? (2 * NumTraits<Scalar>::AddCost +
                   6 * NumTraits<Scalar>::MulCost +
                   scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value)
#else
                ? (11 * NumTraits<Scalar>::AddCost +
                   11 * NumTraits<Scalar>::MulCost +
                   scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value)
#endif
                // This number assumes a naive implementation of tanh
                : (6 * NumTraits<Scalar>::AddCost +
                   3 * NumTraits<Scalar>::MulCost +
                   2 * scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value +
                   functor_traits<scalar_exp_op<Scalar> >::Cost))
  };
};

template<typename Scalar> struct scalar_sinh_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_sinh_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sinh(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psinh(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sinh_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasSinh
  };
};

template<typename Scalar> struct scalar_cosh_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_cosh_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::cosh(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcosh(a); }
};
template<typename Scalar>
struct functor_traits<scalar_cosh_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasCosh
  };
};

template<typename Scalar>
struct scalar_inverse_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_inverse_op)
  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return Scalar(1)/a; }
  template<typename Packet>
  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
  { return internal::pdiv(pset1<Packet>(Scalar(1)),a); }
};
template<typename Scalar>
struct functor_traits<scalar_inverse_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };

template<typename Scalar>
struct scalar_square_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op)
  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a; }
  template<typename Packet>
  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,a); }
};
template<typename Scalar>
struct functor_traits<scalar_square_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };

template<typename Scalar>
struct scalar_cube_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op)
  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a*a; }
  template<typename Packet>
  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,pmul(a,a)); }
};
template<typename Scalar>
struct functor_traits<scalar_cube_op<Scalar> >
{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };

template<typename Scalar> struct scalar_round_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_round_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::round(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pround(a); }
};
template<typename Scalar>
struct functor_traits<scalar_round_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasRound
  };
};

template<typename Scalar> struct scalar_floor_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_floor_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::floor(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pfloor(a); }
};
template<typename Scalar>
struct functor_traits<scalar_floor_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasFloor
  };
};

template<typename Scalar> struct scalar_ceil_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_ceil_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::ceil(a); }
  template <typename Packet>
  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pceil(a); }
};
template<typename Scalar>
struct functor_traits<scalar_ceil_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasCeil
  };
};

template<typename Scalar> struct scalar_isnan_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_isnan_op)
  typedef bool result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isnan)(a); }
};
template<typename Scalar>
struct functor_traits<scalar_isnan_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = false
  };
};

template<typename Scalar> struct scalar_isinf_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_isinf_op)
  typedef bool result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isinf)(a); }
};
template<typename Scalar>
struct functor_traits<scalar_isinf_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = false
  };
};

template<typename Scalar> struct scalar_isfinite_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_isfinite_op)
  typedef bool result_type;
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isfinite)(a); }
};
template<typename Scalar>
struct functor_traits<scalar_isfinite_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::MulCost,
    PacketAccess = false
  };
};

template<typename Scalar> struct scalar_boolean_not_op {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_not_op)
  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a) const { return !a; }
};
template<typename Scalar>
struct functor_traits<scalar_boolean_not_op<Scalar> > {
  enum {
    Cost = NumTraits<bool>::AddCost,
    PacketAccess = false
  };
};

template<typename Scalar,bool iscpx=(NumTraits<Scalar>::IsComplex!=0) > struct scalar_sign_op;
template<typename Scalar>
struct scalar_sign_op<Scalar,false> {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const
  {
      return Scalar( (a>Scalar(0)) - (a<Scalar(0)) );
  }
  //TODO
  //template <typename Packet>
  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }
};
template<typename Scalar>
struct scalar_sign_op<Scalar,true> {
  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)
  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const
  {
    typedef typename NumTraits<Scalar>::Real real_type;
    real_type aa = numext::abs(a);
    if (aa==real_type(0))
      return Scalar(0);
    aa = real_type(1)/aa;
    return Scalar(real(a)*aa, imag(a)*aa );
  }
  //TODO
  //template <typename Packet>
  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sign_op<Scalar> >
{ enum {
    Cost = 
        NumTraits<Scalar>::IsComplex
        ? ( 8*NumTraits<Scalar>::MulCost  ) // roughly
        : ( 3*NumTraits<Scalar>::AddCost),
    PacketAccess = packet_traits<Scalar>::HasSign
  };
};

} // end namespace internal

} // end namespace Eigen

#endif // EIGEN_FUNCTORS_H
```


-------------------------------

Updated on 2022-07-27 at 19:10:15 +0100
