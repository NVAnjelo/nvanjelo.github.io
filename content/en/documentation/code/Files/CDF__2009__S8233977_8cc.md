---

title: "/home/anarendran/Documents/temp/rivet/analyses/pluginCDF/CDF_2009_S8233977.cc"

---

# /home/anarendran/Documents/temp/rivet/analyses/pluginCDF/CDF_2009_S8233977.cc



## Namespaces

| Name           |
| -------------- |
| **[Rivet](http://example.org/namespaces/namespacerivet/)** <br>-*- C++ -*-  |

## Classes

|                | Name           |
| -------------- | -------------- |
| class | **[Rivet::CDF_2009_S8233977](http://example.org/classes/classrivet_1_1cdf__2009__s8233977/)** <br>CDF Run II min-bias cross-section.  |




## Source code

```cpp
// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/Projections/FinalState.hh"
#include "Rivet/Projections/ChargedFinalState.hh"
#include "Rivet/Projections/TriggerCDFRun2.hh"

namespace Rivet {


  class CDF_2009_S8233977 : public Analysis {
  public:

    RIVET_DEFAULT_ANALYSIS_CTOR(CDF_2009_S8233977);




    void init() {
      declare(TriggerCDFRun2(), "Trigger");
      declare(FinalState((Cuts::etaIn(-1.0, 1.0))), "EtFS");
      declare(ChargedFinalState((Cuts::etaIn(-1.0, 1.0) && Cuts::pT >=  0.4*GeV)), "CFS");

      book(_hist_pt ,1, 1, 1);
      book(_hist_pt_vs_multiplicity ,2, 1, 1);
      book(_hist_sumEt ,3, 1, 1);

      book(_sumWeightSelected,"_sumWeightSelected");
    }


    void analyze(const Event& evt) {
      // MinBias Trigger
      const bool trigger = apply<TriggerCDFRun2>(evt, "Trigger").minBiasDecision();
      if (!trigger) vetoEvent;


      const ChargedFinalState& trackfs = apply<ChargedFinalState>(evt, "CFS");
      const size_t numParticles = trackfs.size();
      for (const Particle& p : trackfs.particles()) {
        const double pT = p.pT() / GeV;
        _hist_pt_vs_multiplicity->fill(numParticles, pT);

        // The weight for entries in the pT distribution should be weight/(pT*dPhi*dy).
        //
        // - dPhi = 2*PI
        //
        // - dy depends on the pT: They calculate y assuming the particle has the
        //   pion mass and assuming that eta=1:
        //   dy = 2 * 1/2 * ln [(sqrt(m^2 + (a+1)*pT^2) + a*pT) / (sqrt(m^2 + (a+1)*pT^2) - a*pT)]
        //   with a = sinh(1).
        //
        // sinh(1) = 1.1752012
        // m(charged pion)^2 = (139.57 MeV)^2 = 0.019479785 GeV^2
        const double sinh1 = 1.1752012;
        const double apT  = sinh1 * pT;
        const double mPi = 139.57*MeV;
        const double root = sqrt(mPi*mPi + (1+sinh1)*pT*pT);
        const double dy = std::log((root+apT)/(root-apT));
        const double dphi = TWOPI;
        _hist_pt->fill(pT, 1.0/(pT*dphi*dy));
      }

      // Calc sum(Et) from calo particles
      const FinalState& etfs = apply<FinalState>(evt, "EtFS");
      double sumEt = 0.0;
      for (const Particle& p : etfs.particles()) {
        sumEt += p.Et();
      }
      _hist_sumEt->fill(sumEt);
      _sumWeightSelected->fill();
    }


    void finalize() {
      scale(_hist_sumEt, crossSection()/millibarn/(4*M_PI*dbl(*_sumWeightSelected)));
      scale(_hist_pt, crossSection()/millibarn/dbl(*_sumWeightSelected));
      MSG_DEBUG("sumOfWeights()     = " << sumOfWeights());
      MSG_DEBUG("_sumWeightSelected = " << dbl(*_sumWeightSelected));
    }



  private:

    CounterPtr _sumWeightSelected;
    Profile1DPtr _hist_pt_vs_multiplicity;
    Histo1DPtr _hist_pt;
    Histo1DPtr _hist_sumEt;

  };



  RIVET_DECLARE_ALIASED_PLUGIN(CDF_2009_S8233977, CDF_2009_I817466);

}
```


-------------------------------

Updated on 2022-07-27 at 19:10:14 +0100
