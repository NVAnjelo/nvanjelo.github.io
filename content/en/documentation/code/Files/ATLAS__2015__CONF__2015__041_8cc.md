---

title: "/home/anarendran/Documents/temp/rivet/analyses/pluginATLAS/ATLAS_2015_CONF_2015_041.cc"

---

# /home/anarendran/Documents/temp/rivet/analyses/pluginATLAS/ATLAS_2015_CONF_2015_041.cc



## Namespaces

| Name           |
| -------------- |
| **[Rivet](http://example.org/namespaces/namespacerivet/)** <br>-*- C++ -*-  |

## Classes

|                | Name           |
| -------------- | -------------- |
| class | **[Rivet::ATLAS_2015_CONF_2015_041](http://example.org/classes/classrivet_1_1atlas__2015__conf__2015__041/)**  |
| class | **[Rivet::ATLAS_2015_CONF_2015_041_EL](http://example.org/classes/classrivet_1_1atlas__2015__conf__2015__041__el/)**  |
| class | **[Rivet::ATLAS_2015_CONF_2015_041_MU](http://example.org/classes/classrivet_1_1atlas__2015__conf__2015__041__mu/)**  |




## Source code

```cpp
// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/Projections/ZFinder.hh"
#include "Rivet/Projections/FastJets.hh"
#include "Rivet/Projections/VetoedFinalState.hh"

namespace Rivet {


  class ATLAS_2015_CONF_2015_041 : public Analysis {
  public:



    ATLAS_2015_CONF_2015_041(const string name="ATLAS_2015_CONF_2015_041", size_t channel = 0,
                             const string ref_data="ATLAS_2015_CONF_2015_041")
                             : Analysis(name) {
      _mode = channel; // This class uses the combined e+mu mode
      setRefDataName(ref_data);
    }



    void init() {
      const FinalState fs;

      Cut cuts = (Cuts::pT > 25*GeV) & (Cuts::abseta < 2.5);
      ZFinder zfinder(fs, cuts, _mode? PID::MUON : PID::ELECTRON, 66*GeV, 116*GeV);
      declare(zfinder, "zfinder");

      // Define veto FS in order to prevent Z-decay products entering the jet algorithm
      VetoedFinalState had_fs;
      had_fs.addVetoOnThisFinalState(zfinder);
      FastJets jets(had_fs, FastJets::ANTIKT, 0.4, JetAlg::Muons::ALL, JetAlg::Invisibles::DECAY);
      declare(jets, "jets");

      // individual channels
      book(_hNjets      ,1, 1, _mode + 1);
      book(_hNjetsRatio ,2, 1, _mode + 1, true);
      // combination
      book(_hNjets_comb      ,1, 2, _mode + 1);
      book(_hNjetsRatio_comb ,2, 2, _mode + 1, true);

      _weights.resize(5);
      for (size_t i = 0; i < 5; i++)
        book(_weights[i], "_weights" + to_str(i));
    }


    void analyze(const Event& event) {

      const ZFinder& zfinder = apply<ZFinder>(event, "zfinder");
      const Particles& leptons = zfinder.constituents();
      if (leptons.size() != 2)  vetoEvent;

      Jets jets;
      for (Jet j : apply<JetAlg>(event, "jets").jetsByPt(Cuts::pT > 30*GeV && Cuts::absrap < 2.5)) {
        bool keep = true;
        for(const Particle& l : leptons)  keep &= deltaR(j, l) > 0.4;
        if (keep)  jets += j;
      }

      size_t njets = jets.size();

      for(size_t i = 0; i <= njets; ++i) {
        _hNjets->fill(i + 0.5);
        _hNjets_comb->fill(i + 0.5);
      }

      for (size_t i = 0; i < 5; ++i) {
        if (njets >= i) _weights[i]->fill();
      }

    }



    double ratio(double a, double b) {
      return (b != 0) ? a/b : 0;
    }

    double ratio_err(double a, double b) {
      return (b != 0) ? sqrt(a/b*(1-a/b)/b) : 0;
    }


    void finalize() {
      for (size_t i = 0; i < 4; ++i) {
        double  n = _hNjets->bin(i + 1).sumW();
        double dN = _hNjets->bin(i + 1).sumW2();
        double  d = _hNjets->bin(i).sumW();
        double dD = _hNjets->bin(i).sumW2();
        double r = safediv(n, d);
        double e = sqrt( safediv(r * (1 - r), d) );
        if ( _hNjets->effNumEntries() != _hNjets->numEntries() ) {
          // use F. James's approximation for weighted events:
          e = sqrt( safediv((1 - 2 * r) * dN + r * r * dD, d * d) );
        }
        _hNjetsRatio->point(i).setY(r, e);
        _hNjetsRatio_comb->point(i).setY(r, e);
      }

      scale(_hNjets,      crossSectionPerEvent() );
      scale(_hNjets_comb, crossSectionPerEvent() );
    }



  protected:

    size_t _mode;


  private:

    vector<CounterPtr> _weights;
    Scatter2DPtr _hNjetsRatio, _hNjetsRatio_comb;
    Histo1DPtr _hNjets, _hNjets_comb;
  };



  class ATLAS_2015_CONF_2015_041_EL : public ATLAS_2015_CONF_2015_041 {
  public:
    ATLAS_2015_CONF_2015_041_EL() : ATLAS_2015_CONF_2015_041("ATLAS_2015_CONF_2015_041_EL", 0) { }
  };



  class ATLAS_2015_CONF_2015_041_MU : public ATLAS_2015_CONF_2015_041 {
  public:
    ATLAS_2015_CONF_2015_041_MU() : ATLAS_2015_CONF_2015_041("ATLAS_2015_CONF_2015_041_MU", 1) { }
  };


  RIVET_DECLARE_PLUGIN(ATLAS_2015_CONF_2015_041);
  RIVET_DECLARE_PLUGIN(ATLAS_2015_CONF_2015_041_EL);
  RIVET_DECLARE_PLUGIN(ATLAS_2015_CONF_2015_041_MU);
}
```


-------------------------------

Updated on 2022-07-27 at 19:10:14 +0100
